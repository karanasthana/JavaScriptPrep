(this["webpackJsonpjavascript-prep"]=this["webpackJsonpjavascript-prep"]||[]).push([[0],{112:function(e,t,n){var a={"./javascript.json":23,"./react-js.json":25,"./react-native.json":24,"./redux.json":26};function o(e){var t=i(e);return n(t)}function i(e){if(!n.o(a,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return a[e]}o.keys=function(){return Object.keys(a)},o.resolve=i,e.exports=o,o.id=112},114:function(e,t,n){"use strict";n.r(t);var a=n(0),o=n.n(a),i=n(12),s=n.n(i),r=(n(63),n(16)),l=n(3);n(64);function c(e){return o.a.createElement("div",{className:"section-container",style:{backgroundImage:"url(".concat(e.image,")")}},o.a.createElement("h2",null,"".concat(e.text.toUpperCase())),o.a.createElement(r.b,{className:"button-container",to:{pathname:"/topic/:".concat(e.id),id:"".concat(e.id),json:"".concat(e.json)},id:e.id},o.a.createElement("div",{className:"button"},"Learn ",e.text)))}var u=n(50),d=n.n(u),h=n(51),p=n.n(h),m=n(52),f=n.n(m),w=n(53),g=n.n(w),b=n(23),y=n(24),v=n(25),x=n(26);function k(){return o.a.createElement("div",null,o.a.createElement(c,{image:g.a,text:"Javascript",id:"javascript",json:b}),o.a.createElement(c,{image:p.a,text:"React Native",id:"react-native",json:y}),o.a.createElement(c,{image:f.a,text:"React JS",id:"react-js",json:v}),o.a.createElement(c,{image:d.a,text:"Redux",id:"redux",json:x}))}var q=n(17),j=n.n(q),T=n(116);n(21);function S(e){var t=e.linksList;console.log(t);var n=q.map(t,(function(e,t){return o.a.createElement("li",{key:t},o.a.createElement("a",{target:"_blank",rel:"noopener noreferrer",href:e.link},e.text))}));return""!==t[0].link?o.a.createElement("div",null,o.a.createElement("h1",{className:"topic"},"Important Links"),o.a.createElement("ul",{className:"links-container"},o.a.createElement(T.a,{md:{span:10,offset:1}},n))):""}var R=n(117),E=n(118),A=n(30),D=n.n(A);function W(e){var t=e.questionsAndAnswers;return t.length>0?t.map((function(e,t){return o.a.createElement("div",{key:t},o.a.createElement(T.a,{md:{span:10,offset:1}},o.a.createElement(R.a,null,o.a.createElement(E.a,null,o.a.createElement(R.a.Toggle,{as:E.a.Header,className:"toggle-card",eventKey:t},D()(e.question)),o.a.createElement(R.a.Collapse,{eventKey:t},o.a.createElement(E.a.Body,null,D()(e.answer)))))))})):null}var I=n(56),O=n.n(I);function C(e){return o.a.createElement("div",{className:"qa-container",style:{backgroundImage:"url(".concat(O.a,")")}},o.a.createElement("img",{src:e.logo,alt:"Topic Logo",className:"logo"}),o.a.createElement("h1",{className:"topic"},e.topic))}var M=n(119);function J(e){var t=n(112)("./".concat(e.match.params.id.substr(1),".json"));return o.a.createElement("div",{className:"detail-container"},o.a.createElement(M.a,{onClick:function(e){var t=document.getElementsByClassName("toggle-card");j.a.each(t,(function(e){e.click()})),e.target.innerHTML="Expand All"===e.target.innerHTML?"Collapse All":"Expand All"},className:"expand-collapse-all",id:"ExpColBtn"},"Expand All"),o.a.createElement(C,{logo:t.logo,topic:t.topic}),o.a.createElement(W,{questionsAndAnswers:t.questionsAndAnswers}),o.a.createElement(S,{linksList:t.importantLinks}))}var P=function(){return o.a.createElement(r.a,null,o.a.createElement(l.c,null,o.a.createElement(l.a,{path:"/topic/:id",name:"Topic",component:J}),o.a.createElement(l.a,{path:"/"},o.a.createElement(k,null))))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));n(113);s.a.render(o.a.createElement(o.a.StrictMode,null,o.a.createElement(P,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()})).catch((function(e){console.error(e.message)}))},21:function(e,t,n){},23:function(e){e.exports=JSON.parse('{"topic":"JavaScript","importantLinks":[{"link":"https://medium.com/front-end-weekly/javascript-event-loop-explained-4cd26af121d4","text":"Event Loop"},{"link":"https://www.telerik.com/blogs/debouncing-and-throttling-in-javascript#:~:text=Throttling%20is%20a%20technique%20in,Hello%2C%20world%20on%20the%20console.","text":"Difference between Deboucing and Throttling"},{"link":"https://www.javatpoint.com/how-ajax-works","text":"How does Ajax work with Javascript"},{"link":"https://javascript.info/property-accessors","text":"Getters and Setters"},{"link":"https://zerotomastery.io/courses/advanced-javascript/cheatsheet/","text":"Important JS concepts"},{"link":"https://css-tricks.com/understanding-event-emitters/","text":"Implementing Event Emitters in JavaScript"},{"link":"https://vanillajstoolkit.com/polyfills/arrayfind/","text":"Create a polyfill for Array.prototype.find()"}],"logo":"https://javascript-prep.s3.ap-south-1.amazonaws.com/JavaScript-logo.png","questionsAndAnswers":[{"question":"<h3>Hoisting</h3>","answer":"Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution regardless of whether their scope is global or local. Every time you write a program in javascript, it runs in an environment and that environment is called execution context. There are two types of execution contexts: <ul><li>Global Execution Context</li><li>Execution Context created every time after a function is created. Every time a function is called the new execution context is pushed to the top of the global execution context, which makes an execution stack.</li></ul>An undeclared variable is assigned the value undefined at execution and is also type undefined. A ReferenceError is thrown when trying to access a previously undeclared variable.<br>Function declarations are hoisted and Function expressions are not .. gives typeError"},{"question":"<h3>JavaScript Functions</h3>","answer":"<p>2 types of JS functions</p><ol><li>Function declaration and 2. Function Expression</li><li>The Function Declaration is created when JavaScript is preparing to start the script and is visible everywhere in it.<code>function foo(){}</code></li><li>Function Expressions are created when the execution reaches them.<code>let foo = function(){}</code>Difference</li><li>Syntax</li><li>The main difference between a function expression and a function declaration is the function name, which can be omitted in function expressions to create anonymous functions.</li><li>FE can be used as an IIFE.*can&#39;t use function expression before creating them (because they are not hoisted).</li></ol>"},{"question":"<h3>Closures</h3>","answer":"<p>A closure is an inner function which gives you access to an outer function\u2019s scope from inside even before the function is returned. In JavaScript, closures are created every time a function is created, at function creation time. A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time the closure was created.</p> <p>what happens internally is: outer function execution goes into the execution stack first, then the variables goes into symbols table. Variable remains there till the execution of the function is completed. Then comes the inner function, it goes in execution stack and can access variable from symbols table. Once the execution of outer function is completed you can&#39;t access the variable outside. Also, you can&#39;t access the variables declared inside the inner function. <code>function runExecution() { var a = 10; function add(b){ var b = 20;return a + b;} add();}</code></p><p>Further explanation to that &quot;reference&quot; concept: Point 1: &quot;An object is marked as eligible to be garbage collected when it can no longer be accessed.&quot; As you can&#39;t initiate garbage collection process manually in javascript, JS engine determines the eligibility of an object for GC using the above mentioned point. FYI, this is applicable for all types of objects.</p><p>But if there&#39;s a reference somewhere, which means if it can still be accessed (In case of closure, inner function still has reference preserved for variables defined in outer function), which means it still stays in the Heap memory &amp; garbage collector doesn&#39;t consider these variables.</p> "},{"question":"<h3>Spread and Rest operator</h3>","answer":"<p>The spread operator takes an array (or any iterable) and spreads its values. The spread operator takes the array of parameters and spreads them across the arguments in the function call. But what if we need our function to be able to work with an unknown number of parameters? That\u2019s where the rest parameter comes in. The rest parameter gives us an easier and cleaner way of working with an indefinite number of parameters</p> <p><strong>Arguments</strong> is like rest operator, it was used in old javascript but the difference between these both is, arguments creates an array like structure but not array, so we can&#39;t use methods of array, for example array.map(..)</p></p> <ul> <li>Spread syntax internally uses iterator, as for...of</li> <li>Rest parameters are used to create functions that accept any number of arguments.</li> <li>The spread syntax is used to pass an array to functions that normally require a list of many arguments.  </li> </ul> <p>Uses of spread operator-&gt; </p> <ul> <li>Make copies of array or object. </li> <li>Merge arrays</li></ul>"},{"question":"Differences between var and let","answer":"<ol> <li>Scope: var variables are function scoped and let variables are block scoped.</li> <li>Hoisting: var variables are hoisted, let will throw referenceError.</li> <li>Global object: var variables are created as a global object i,e, are attached to window object, but let variables are not. (which means var are wasting memory attaching every variable to the global object.)</li> <li>Redeclaration:  <code>var foo = 20; var foo;</code> its ok but will throw an error in strict mode but <code>let bar = 20; let 20;</code> is not ok. </li> </ol>"},{"question":"Differences between normal function and arrow function","answer":"<ol><li>syntax</li> <li>no arguments binding in arrow functions</li> <li>use of this keyword -&gt; arrow functions do not have their own this.</li> <li>using new keyword: regular functions are callable and constructible. but arrow functions are only callable and not constructible.</li> <li>no duplicate name parameters</li> </ol>"},{"question":"HOF: Higher order functions","answer":"<p>A higher-order function is a function that can take another function as an argument, or that returns a function as a result. When you pass a function by name without parentheses, you are passing the function object itself. When you pass it with parentheses, you are passing the result of executing that function.</p>"},{"question":"Difference between null and undefined","answer":"<ul><li>null is an object whereas undefined is of type undefined.</li><li>null !== undefined but null == undefined</li><li>undefined means a variable is declared but not assigned a value whereas null is an assigned value.</li></ul>"},{"question":"Deep copy and Shallow copy","answer":"<p>If we make a copy by assigning a variable to another variable <code>b = a</code> , and change some nested value in <code>b</code>, it actually changes <code>a</code>\u2019s nested value as well, since <code>a</code> and <code>b</code> actually point to the same thing. <br /> Shallow copy in objects can be done by <strong>spread operators</strong>, <strong>Object.assign({}, obj)</strong> and <strong>obj.slice()</strong>; Shallow copy in arrays: <strong>spread</strong>, <strong>Array.from(arr)</strong></p> <p>When an object variable is copied \u2013 the reference is copied, the object is not duplicated. So what if we have a nested object, in that case nested properties are also copied by reference and change in nested properties will be reflected in the original array (this is called shallow copy). To solve this issue we&#39;ll use deep cloning. Deep copy: <code>JSON.parse(JSON.stringify(obj))</code></p> This is not a suggested method as it takes time to parse json and it\'s not optimised if we have a deep deep deep object. In that case we should know how to design our own deep cloning algorithm."},{"question":"Typecasting or coercion","answer":"<p>it means changing data type of a value to to another data type. 2 types</p> <ul> <li>implicit-&gt; automatic conversion of data type</li> <li>explicit-&gt; type conversion example.. parseInt(), parseFloat(),  String(), Boolean()</li> </ul>"},{"question":"Features of ES6","answer":"<ol><li>Constants</li><li>Block scoped variables and block scoped functions</li><li>arrow functions</li><li>Destructring</li><li>Template Literals</li><li>Extended parameter handling using Rest and Spread</li></ol>"},{"question":"Promises","answer":"<p>Promises lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future. A Promise can be in one of the 3 states</p> <ul> <li>Pending</li> <li>Fulfilled</li> <li>Rejected</li> </ul>"},{"question":"Event loop","answer":"Refer to Important Links for an amazing article about event loop"},{"question":"Bind, call and apply","answer":"<ul> <li>The bind() method creates a new function that, when called, has its <em>this</em> keyword set to the provided value. </li> <li>Call() expects all parameters to be passed in individually, whereas apply() expects an array of all of our parameters. Difference between call and bind is:</li> <li>Executes the function it was called upon right away.</li> <li>The call() method does not make a copy of the function it is being called on.</li> </ul>"},{"question":"Debouncing","answer":"Debouncing is a programming practice used to ensure that time-consuming tasks do not fire so often, that it stalls the performance of the web page. In other words, it limits the rate at which a function gets invoked."},{"question":"Throttling","answer":"Throttling is a technique in which, no matter how many times the user fires the event, the attached function will be executed only once in a given time interval."},{"question":"Difference between throttling and debouncing","answer":"Throttling will delay executing a function. It will reduce the notifications of an event that fires multiple times. Debouncing will bunch a series of sequential calls to a function into a single call to that function. It ensures that one notification is made for an event that fires multiple times. Refer to Important Links for an amazing article about Differences between throttling and debouncing"},{"question":"This keyword","answer":"<p>The value of this is determined by how a function is called (runtime binding). A property of an execution context (global, function or eval) that, in non\u2013strict mode, is always a reference to an object and in strict mode can be any value.</p><ul><li>Global Context- In global execution context, <em>this</em> always refer to the window object or global object whether in strict mode or not.</li><li>Function Context- Inside a function, the value of this depends on how the function is called. To set the value of this to a particular value when calling a function, use call(), or apply()</li> </ul>. Also, this is an object which the function is a property of. So, how can we use <code>this</code> differently. <br /> 1st: <code>new binding this</code> Where we actually instantiate a class or a function. Which allows us to assign this to the object that we instantiated.<br /> 2nd: <code>Implicit bindind</code> When we just create an object and inside that object this refers to the object in which it is in. <br /> 3rd: <code>Explicit binding</code> Which can be done by binding it to an external value. By using bind, call or apply. <br /> 4th: <code>Arrow functions</code> by using arrow functions we can do lexical scoping that means, where ever we write the function, that\'s what this binds to."},{"question":"Object.preventExtensions()","answer":"It is a method that simply converts an object passed as the argument into a non-extensible state. This method doesn\'t allow us to add new properties but the value of properties can be changed and also allow us to delete the existing properties."},{"question":"Currying","answer":"<p>Currying is the pattern of functions that immediately evaluate and return other functions. This is made possible by the fact that Javascript functions are expressions that can return other functions.</p> <p>Curried functions are constructed by chaining closures by defining and immediately returning their inner functions simultaneously.<code>function curry(f) { // curry(f) does the currying transform return function(a) { return function(b) { return f(a, b); }; }; }</code></p>"},{"question":"Nullish coalescing operator \'??\'","answer":"<p>The nullish coalescing operator ?? provides a short syntax for selecting a first \u201cdefined\u201d variable from the list. <code>height = height ?? 100;</code> sets height to 100 if it is undefined</p>"},{"question":"Map & Set","answer":"<ul> <li>Map is a collection of keyed data items, just like an Object. But the main difference is that Map allows keys of any type. </li> <li>Methods: <code>map.get()</code> , <code>map.set()</code> </li> <li>A Set is a special type collection \u2013 \u201cset of values\u201d (without keys), where each value may occur only once.</li> </ul> "},{"question":"Object iteration","answer":"Object.keys(), Object.values(), Object.entries() "},{"question":"Who listens to promises? how does it know which state is the promise in?","answer":""},{"question":"What is AJAX and how does it work?","answer":"AJAX (Asynchronous JavaScript and XML) allows applications to transport data to/from a server asynchronously without refreshing the page. This means that it is likely to update parts of a web page, without reloading the entire page. "},{"question":"How does JS handle ajax requests?","answer":"User sends a request from the UI and a javascript call goes to XMLHttpRequest object. HTTP Request is sent to the server by XMLHttpRequest object. Server interacts with the database using JSP, PHP, Servlet, ASP.net etc. Data is retrieved. Server sends XML data or JSON data to the XMLHttpRequest callback function. HTML and CSS data is displayed on the browser."},{"question":"Difference between process and thread in browser","answer":"chrome uses multiprocessing and firefox uses multi threading. so each tab in chrome is a <strong>process</strong>, whereas in firefox each tab is a <strong>thread</strong>. since multithreading is faster, firefox is faster(due to shared memory, context switching is faster in threads). However, it is important to note that, chrome is less likely to crash since if one tab(process) crashes, it won\'t crash the entire browser. opposite is true in case of firefox."},{"question":"What happens internally in the browser when we load html css and js","answer":"A DOM is created using the HTML files. Starting from the<code> < body > </code>tag. The javascript files and the css files are also loaded as extras in the DOM. These javascript file contents eventually contain some functions, which are then called as per the user\'s code logic. The Css classes get applied to the DOM elements while rendering the DOM"},{"question":"array of users data and that data is paginated, only 10 are shown at a time, now second batch is loading and user clicks somewhere else and that takes time to give response. What will load first? (2nd batch of users or response )","answer":""},{"question":"What is Destructuring?","answer":"The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables."},{"question":"What is Prototypal Inheritance?","answer":"In JavaScript, objects have a special hidden property [[Prototype]] (as named in the specification), that is either null or references another object. That object is called <em>a prototype</em>. When we want to read a property from object, and it\u2019s missing, JavaScript automatically takes it from the prototype. This is called \u201cprototypal inheritance\u201d. Further understanding of prototypal inheritance: Only constructor functions have <code>prototype</code> property. If we check to see prototype property on a regular function, it will be undefined"},{"question":"What are getters and setters","answer":"Refer to important links"},{"question":"What are Web Workers","answer":"A web worker is a JavaScript that runs in the background, independently of other scripts, without affecting the performance of the page. You can continue to do whatever you want: clicking, selecting things, etc., while the web worker runs in the background. <br /> A worker is an object created using a constructor (e.g. Worker()) that runs a named JavaScript file \u2014 this file contains the code that will run in the worker thread; workers run in another global context that is different from the current window. Thus, using the window shortcut to get the current global scope (instead of self) within a Worker will return an error."},{"question":"Object.create()","answer":"Object.create() creates a new empty object for us and is used to achieve prototypal inhertitance (We don\'t use it though as it\'s not object oriented paradigm). Suppose we have an object with certain methods or properties which we want to re use in several other functions. We can provide that object\'s name into the argument of object.create(). <br /> Example: <code> let usable = {talk(){return \'Bla Bla\'}}</code><br /> <code>let useUsable = Object.create(usable)</code> <br /> Now, it creates a new empty object useUsable which has the talk() method."},{"question":"Difference between window object and this","answer":"Window object always refers to the global object or global variables. But value of <code>this</code> can vary according to how it is called. We should always remember this: <code>this</code> is an object which the function is a property of. That means where this is called."},{"question":"Difference between local storage, session storage and cookie storage","answer":"Local storage survives browser close and even computer shut down, whereas session storage saves data only until the tab is closed. "},{"question":"Give different methods to load javascript asynchronously in html5","answer":"We have 2 methods to load javascript files asynchronously in html. <ul><li><strong>async</strong> if we are calling a js file by using async keyword in the script tag, then the execution of HTML file and loading of js file goes in parallel. After the loading of file, our js file executes then and there, then if we have any other html elements then they are exectured or run.</li><li><strong>defer</strong> keyword when used, it executes the html file and loads js file paralelly, then any of the remaining html file is executed. After complete execution of html file, the js script is executed. </li></ul>"},{"question":"Does JS has classes?","answer":"Well, yes they are just syntactic sugar but <code>class</code> keyword is still just prototypal inheritance. It can also be said as <code>Pseudo classical inheritance</code> because it\'s not real classical inheritance. Methods to be shared are written outside the constructor function because everytime we instantiate a class, a constructor function is run and it may have different values while instantiating. But every instantiated object needs that method which is why it is put outside to make it shareable."},{"question":"Difference between async await and promises","answer":"<ol><li>Only the promise chain itself is asynchronous in Promises but the whole wrapper function in case of async await is asynchronous.</li> <li>To resolve multiple promises using promise chain, we use Promise.all() But with async await we can simply await both promises, store the results in variables, and use them later in the code block.</li></ol>"},{"question":"Difference between foreach, filter and map","answer":""},{"question":"Benefits of template literals","answer":""},{"question":"Page can load without css?","answer":""},{"question":"Naming convention for css classes","answer":""},{"question":"Callback hell","answer":"Asynchronous JavaScript, or JavaScript that uses callbacks, is hard to get right intuitively. A lot of code ends up looking like, if this happens then this and then this and then this causing the pyramid of coode."},{"question":"Event bubbling, capturing","answer":"These are 2 ways of event propogation in the DOM tree. If any event occurs in child, it propogates to its parent as well. It means, it moves up to the heirarchy. We can stop this proppgation by using stopPropogation()"},{"question":"What are Event Emitters and how to create your own event emitters in JavaScript?","answer":"An event emitter is a pattern that listens to a named event, fires a callback, then emits that event with a value. For its implementation, refer to the useful links"},{"question":"Make a polyfill of an array method","answer":"A polyfill is a piece of code (usually JavaScript on the Web) used to provide modern functionality on older browsers that do not natively support it. In this process, at first the method is attached to the array prototype and then the function is returned. For more details, refer to the useful links for creating a polyfill of Array.prototype.find()"}]}')},24:function(e){e.exports=JSON.parse('{"topic":"React Native","importantLinks":[{"link":"","text":""},{"link":"","text":""}],"logo":"https://javascript-prep.s3.ap-south-1.amazonaws.com/react-logo.png","questionsAndAnswers":[{"question":"Flat list and Section List","answer":"<ul> <li>The FlatList component displays a scrolling list of changing, but similarly structured, data. FlatList works well for long lists of data, where the number of items might change over time. Takes 2 props: data and renderItem.</li> <li>If you want to render a set of data broken into logical sections, maybe with section headers, similar to UITableViews on iOS, then a SectionList is the way to go. Props: renderItem, sections, renderSectionHeader.</li> </ul> "},{"question":"Difference between flat list and scroll view","answer":"<ul> <li>ScrollView will load items (data in it for scrolling) immediately after component loading. So all data will mount into RAM and you can&#39;t use hundred or thousand items in it (because of low performance).</li> <li>FlatList has a better solution for this issue, it will mount 10 items (by default) to screen, if user scroll view so other items will mount. It&#39;s a big gain of FlatList instead of ScrollView. </li> </ul> "},{"question":"ScrollView","answer":"<p>The ScrollView is a generic scrolling container that can contain multiple components and views. The scrollable items need not be homogeneous, and you can scroll both vertically and horizontally (by setting the horizontal property).</p> <ul> <li><strong>PagingEnabled</strong> prop: used to allow paging through views using swiping gestures.</li> <li>View-pager component is used to swipe right and left</li> </ul> "},{"question":"PopToTop()","answer":"When we are several screens deep in a stack and want to dismiss all of them to go back to the first screen, we can use poptotop function. It will go back to the first screen in the stack."},{"question":"Difference between navigation.push() and navigation.navigate()","answer":"The Push action adds a route on **top of the stack** and navigates forward to it. This differs from navigate in that navigate will pop back to earlier in the stack if a component is already mounted there. Push will always add on top, so a component can be mounted multiple times."},{"question":"What are native modules","answer":""},{"question":"What is interaction manager","answer":"The interaction manager is a native module present in React Native with the workability of deferring the execution of a function until an \u2018interaction\u2019 has finished. This module is crucial because React Native has only one thread for making UI updates which can be overloaded and result in drop frames. Developers use interaction manager to ensure that the function is only executed after the animations occurred so that any frame drops may not result."},{"question":"How to do pagination in flat list","answer":""},{"question":"What is < SafeAreaView >","answer":""},{"question":"What are default props","answer":""},{"question":"What is async storage","answer":""}]}')},25:function(e){e.exports=JSON.parse('{"topic":"ReactJS","importantLinks":[{"link":"https://itnext.io/add-state-and-lifecycle-methods-to-function-components-with-react-hooks-8e2bdc44d43d","text":"Hooks for statefull functional components"},{"link":"https://medium.com/@Zwenza/functional-vs-class-components-in-react-231e3fbd7108","text":"When to choose what components"},{"link":"https://medium.com/@suhas010/what-the-heck-is-repaint-and-reflow-in-the-browser-b2d0fb980c08","text":"Repainting and Reflow"},{"link":"https://www.codingame.com/playgrounds/8595/reactjs-higher-order-components-tutorial#:~:text=A%20higher%2Dorder%20component%20(HOC,the%20advanced%20technique%20in%20React.&text=They%20are%20the%20pattern%20that,Redux\'s%20connect%20and%20Relay\'s%20createContainer.","text":"Higher Order Component"},{"link":"https://medium.com/better-programming/when-to-use-react-purecomponent-723f85738be1#:~:text=PureComponent%20Is%20Primarily%20Used%20for,performance%20boost%20in%20some%20cases.","text":"When to use Pure Components"}],"logo":"https://javascript-prep.s3.ap-south-1.amazonaws.com/react-logo.png","questionsAndAnswers":[{"question":"React and Virtual Dom","answer":"<p>React creates a virtual DOM. When state changes in a component it firstly runs a <strong>diffing</strong> algorithm, which identifies what has changed in the virtual DOM. The second step is reconciliation, where it updates the DOM with the results of diff. Whenever a ReactComponent is changing the state, diff algorithm in React runs and identifies what has changed. And then it updates the DOM with the results of diff. The point is - it\u2019s done faster than it would be in the regular DOM.</p> "},{"question":"Lifecycle of react components","answer":"<ul> <li><strong>Initialization</strong> where constructor function is called to set things up, generally states and props.</li> <li><strong>Mounting</strong> Component renders for the first time and 2 methods are available- <em>ComponentDidMount</em> and <em>ComponentWillMount</em>. How it happens is, willMount is called just before the render method and is called only once in the entire lifecycle. After render method didMount is called.</li> <li><strong>Updating</strong> where component&#39;s state and props changes and it re renders on the page. 4 methods are available at this time:</li> </ul> <p><em>componentWillReceiveProps</em> receives props, </p> <p> <em>ShouldComponentUpdate</em> is called just before the component is re rendered and tells whether the component should be updated or not. By default, it returns true.</p> <p><em>componentWillUpdate</em> it is called just before the new component gets rendered.</p> <p><em>componentDidUpdate</em> This method is called just after the re-rendering of the component. You will have access to the previous props and state with prevProp and prevState as well as the current ones, and you can use this method to update any third party libraries if they happen to need an update due to the re-render.</p> <ul> <li><strong>Unmounting</strong> : At the unmounting stage, the component gets deleted and removed from the page. The only lifecycle method at this stage is componentWillUnmount, which is called just before the component gets deleted. It is used to clear anything that was set up in componentDidMount</li> </ul> "},{"question":"How does virtual DOM know what has changed in the list of elements","answer":"When state changes occur, the virtual DOM is updated and the previous and current version of virtual DOM is compared. This is called <strong>diffing</strong>. The virtual DOM then sends a batch update to the real DOM to update the UI. <br /> React doesn\u2019t really do anything new. It\u2019s just a strategic move. What it does is It stores a replica of real DOM in memory. When you modify the DOM, it first applies these changes to the in-memory DOM. Then, using it\u2019s diffing algorithm, figures out what has really changed. Finally, it batches the changes and call applies them on real-dom in one go. Thus, minimizing the re-flow and re-paint."},{"question":"React.createElement()","answer":"<p><code>React.createElement( type, [props], [...children] )</code> Create and return a new React element of the given type. The type argument can be either a tag name string (such as &#39;div&#39; or &#39;span&#39;), a React component type (a class or a function), or a React fragment type.</p>"},{"question":"Why React?","answer":"<ul><li>Virtual DOM.</li><li>It\u2019s Easier to Learn for developers.</li><li>React enables developers to reuse components.</li><li>It provides a unique Abstraction Layer: It provides a good abstraction layer, which means an end-user can\u2019t access the complex internals.</li></ul>"},{"question":"How to make use of component lifecycle in functional methods","answer":"Use React Hooks to use states in functional components. Read more about it in the important links section."},{"question":"Differences between functional and class components","answer":"Refer to the important links."},{"question":"Differences between Repainting and Reflow","answer":"Refer to the important links."},{"question":"React is unidirectional or bidirectional. Explain unidirectional flow.","answer":"React is unidirectional. <br/> Unidirection flow is one where you can pass on data in any one direction (either always parent to child or always child to parent). <br/> React JS is an unidirectional flow wherein data can be passed only from parent to child."},{"question":"Why is setState() async","answer":"setState() is async because React intelligently combines several setState functions into one and thus, change the virtual DOM only once for several setState calls performed in a short span of time. Also, there is no guarantee that the state has been updated if we try to access the value immediately"},{"question":"Is there any memory leak in react?","answer":"Can\'t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method."},{"question":"examples of HOC","answer":"Refer to important links"},{"question":"how do you create react builds","answer":"We use <strong>npm</strong> to create react builds. Using the commands <code>npm run build</code>. Ususally the build script is run using this command. Commonly the build script is used to create minified deployable versions of all the javascript code into one, all the css code into one and all HTML into one."},{"question":"What are Pure Components","answer":"React.PureComponent is similar to React.Component. The difference between them is that React.Component doesn\u2019t implement shouldComponentUpdate(), but React.PureComponent implements it with a shallow prop and state comparison. If your React component\u2019s render() function renders the same result given the same props and state, you can use React.PureComponent for a performance boost in some cases."},{"question":"Alternative of React.PureComponent","answer":""},{"question":"If parent component contains a child component, Will child component re renders if render function of parent is called?","answer":"Yes, and to avoid this we should use pure components."},{"question":"if there are multiple css files in components and one in global how are they loaded?","answer":""},{"question":"If you have a lot of components and page is taking a lot of time to load how will you check where is the code failing?","answer":""},{"question":"How to do server side rendering?","answer":""},{"question":"React lazy loading and Suspense","answer":"React.lazy() and < Suspense />"},{"question":"how to cancel fetch operation if previous fetch didn\'t return a response?","answer":""},{"question":"Apply something in a DOM node like document.getElementById in react","answer":"use React.findDOMNode()"},{"question":"Reason behind not using id as an index in map","answer":""},{"question":"Difference between state and props","answer":""},{"question":"Why should we not mutate state directly? By assigning like <code>this.state.a = 10</code>","answer":"setState() is not immediate. It queues a state transition based on what it thinks is going on which may not include the direct changes to this.state. Since it\'s queued rather than applied immediately, it\'s entirely possible that something is modified in between such that your direct changes get overwritten. Basically, if you modify this.state directly, you create a situation where those modifications might get overwritten."},{"question":"Why this.setState should not be called inside render method?","answer":" setState() calls render, and calling a function mutating the state inside render generally leads to an infinite loop."}]}')},26:function(e){e.exports=JSON.parse('{"topic":"Redux","importantLinks":[{"link":"https://frontarm.com/james-k-nelson/when-context-replaces-redux/#:~:text=React\'s%20context%20API%20does%20basically,whole%20toolkit%20for%20managing%20state%3A&text=It%20provides%20a%20middleware%20API,to%20tools%20like%20redux%2Dsagas","text":"Context API and when to choose it over Redux"},{"link":"https://www.educba.com/redux-alternatives/","text":"What is Redux and it\'s alternatives"},{"link":"https://www.digitalocean.com/community/tutorials/redux-redux-intro#:~:text=Redux%20is%20a%20predictable%20state,just%20plain%20old%20vanilla%20JavaScript.","text":"Redux\'s Core Concepts and design pattern"}],"logo":"https://javascript-prep.s3.ap-south-1.amazonaws.com/redux-logo.png","questionsAndAnswers":[{"question":"Reducers","answer":"Reducers are just pure functions that take the previous state and an action, and return the next state. <br /> The state of a store is updated by means of reducer functions. A stable collection of a reducers form a store and each of the stores maintains a separate state associated for itself."},{"question":"Actions","answer":"Actions are payloads of information that send data from your application to your store. They are the only source of information for the store. You send them to the store using store.dispatch()"},{"question":"Connect()","answer":"The connect() function connects a React component to a Redux store. Parameters: mapStateToProps, MapDispatchToProps. <strong>mapStateToProps</strong> maps the state variables from your store to the props that you specify."},{"question":"Redux Alternative","answer":"Read about Context API. Or 3rd party libraries like Realm"},{"question":"Why do we need Redux to store state, why not react\'s state and props?","answer":"<p>React is unidirectional. So to have access to a global level state, we use redux</p> <ul><li>Application\'s state is meant to be kept as small as possible and therefore, if our application is quite big and we have varous states, we should store it in a global store: redux.</li> <li>Things like authentication while login requires auth token to be saved in a global state, in that case we should use redux store. </li><li>Using redux separates business logic from design which in turn improves code readabily and maintainability</li></ul>"},{"question":"Difference between context api and redux","answer":""},{"question":"Examples of when to use redux and when not","answer":"Uncomplicated websites that do not require sibling communication or child to parent communication, should ideally not use redux. Whereas applications/websites with complex logic and with the need to communicate between siblings/from child to parent need to use a global level state like Redux."},{"question":"What is Redux flow or Redux Design Pattern ?","answer":"Call-back from UI component dispatches an action with a payload, these dispatched actions are intercepted and received by the reducers. This interception will generate a new application state. From here the actions will be propagated down through a hierarchy of components from Redux store."},{"question":"Store","answer":"The store holds the application state and supplies the helper methods for accessing the state, register listeners and dispatch actions. There is only one Store while using Redux. The store is configured via the <strong>createStorefunction</strong>. The single store represents the entire state. Rducers return a state via action <br /> <code>export function configureStore(initialState) { return createStore(rootReducer, initialState); }</code> <br /> The root reducer is a collection of all reducers in the application."},{"question":"Why is Redux Thunk used","answer":"Redux Thunk is a middleware that allows you to write action creators that return a function instead of an action. The thunk can be used to delay the dispatch of an action, or to dispatch only if a certain condition is met. The inner function receives the store methods dispatch and getState() as parameters. Thereby, middlewares like Redux Thunk or Redux Sagas are used to make the Redux asynchronous."}]}')},50:function(e,t,n){e.exports=n.p+"static/media/coding.ac092b15.jpg"},51:function(e,t,n){e.exports=n.p+"static/media/mobile-dev.ad3dfdd1.jpg"},52:function(e,t,n){e.exports=n.p+"static/media/computer-table.4fdf6d5b.jpg"},53:function(e,t,n){e.exports=n.p+"static/media/computer.a277703e.jpg"},56:function(e,t,n){e.exports=n.p+"static/media/common.122b5b53.webp"},58:function(e,t,n){e.exports=n(114)},63:function(e,t,n){},64:function(e,t,n){},94:function(e,t){}},[[58,1,2]]]);
//# sourceMappingURL=main.e74fe9ee.chunk.js.map